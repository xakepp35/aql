package ast

import (
	"fmt"

	"github.com/xakepp35/aql/internal/vmi"
)

func (n *Number) Compile(e vmi.ter) error {
	e.Ops(op.PushNum)
	e.ArgStr(string(n.Text))
	return nil
}

func (s *String) Compile(e vmi.ter) error {
	e.Ops(op.PushStr)
	e.ArgStr(string(s.Text))
	return nil
}

func (b *Bool) Compile(e vmi.ter) error {
	e.Ops(op.PushBool)
	if b.Val {
		e.Arg(1)
	} else {
		e.Arg(0)
	}
	return nil
}

func (n *Null) Compile(e vmi.ter) error {
	e.Ops(op.PushNull)
	return nil
}

func (i *Ident) Compile(e vmi.ter) error {
	e.Ops(op.Var)
	e.ArgStr(string(i.Name))
	return nil
}

// ---------- унарное ----------

func (u *UnaryExpr) Compile(e Emitter) error {
	if err := u.X.Compile(e); err != nil {
		return err
	}
	switch u.Op {
	case "-":
		// реализуем отрицание как "push 0; swap; sub"
		e.Ops(OpPushNum)
		e.ArgStr("0")
		e.Ops(OpSwap) // нужна доп-инстр., либо сделать OpNeg
		e.Ops(OpSub)
	default:
		return fmt.Errorf("unsupported unary op: %s", u.Op)
	}
	return nil
}

// ---------- бинарное ----------

func (b *BinaryExpr) Compile(e Emitter) error {
	if err := b.Left.Compile(e); err != nil {
		return err
	}
	if err := b.Right.Compile(e); err != nil {
		return err
	}
	switch b.Op {
	case "+":
		e.Ops(OpAdd)
	case "-":
		e.Ops(OpSub)
	case "*":
		e.Ops(OpMul)
	case "/":
		e.Ops(OpDiv)
	case "%":
		e.Ops(OpMod)
	default:
		return fmt.Errorf("unknown binary op %q", b.Op)
	}
	return nil
}

// ---------- сравнения ----------

func (c *CompareExpr) Compile(e Emitter) error {
	if err := c.Left.Compile(e); err != nil {
		return err
	}
	if err := c.Right.Compile(e); err != nil {
		return err
	}
	switch c.Op {
	case "==":
		e.Ops(OpEq)
	case "!=":
		e.Ops(OpNeq)
	case "<":
		e.Ops(OpLt)
	case "<=":
		e.Ops(OpLe)
	case ">":
		e.Ops(OpGt)
	case ">=":
		e.Ops(OpGe)
	default:
		return fmt.Errorf("unknown compare op %q", c.Op)
	}
	return nil
}

// ---------- логика ----------

func (l *LogicalExpr) Compile(e Emitter) error {
	if err := l.Left.Compile(e); err != nil {
		return err
	}
	if err := l.Right.Compile(e); err != nil {
		return err
	}
	switch l.Op {
	case "&&":
		e.Ops(OpAnd)
	case "||":
		e.Ops(OpOr)
	default:
		return fmt.Errorf("unknown logical op %q", l.Op)
	}
	return nil
}

// ---------- вызовы ----------

func (c *CallExpr) Compile(e Emitter) error {
	for _, a := range c.Args {
		if err := a.Compile(e); err != nil {
			return err
		}
	}
	e.Ops(OpCall)
	e.ArgStr(string(c.Fun))
	e.Arg(uint32(len(c.Args)))
	return nil
}

// ---------- селекторы ----------

func (f *FieldSel) Compile(e Emitter) error {
	if err := f.X.Compile(e); err != nil {
		return err
	}
	e.Ops(OpField)
	e.ArgStr(string(f.Name))
	return nil
}

func (ix *IndexExpr) Compile(e Emitter) error {
	if err := ix.X.Compile(e); err != nil {
		return err
	}
	if err := ix.I.Compile(e); err != nil {
		return err
	}
	if ix.J == nil {
		e.Ops(OpIndex1)
	} else {
		if err := ix.J.Compile(e); err != nil {
			return err
		}
		e.Ops(OpIndex2)
	}
	return nil
}

// ---------- Pipe & Over ----------

func (p *PipeExpr) Compile(e Emitter) error {
	if err := p.Left.Compile(e); err != nil {
		return err
	}
	if err := p.Right.Compile(e); err != nil {
		return err
	}
	e.Ops(OpPipe)
	return nil
}

func (o *OverExpr) Compile(e Emitter) error {
	// Seq
	if err := o.Seq.Compile(e); err != nil {
		return err
	}
	// Scope (может быть nil)
	if o.Scope != nil {
		if err := o.Scope.Compile(e); err != nil {
			return err
		}
	} else {
		e.Ops(OpPushNull) // пустой scope
	}
	e.Ops(OpOver)
	return nil
}
